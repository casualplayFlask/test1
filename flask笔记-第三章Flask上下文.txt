Flask中有两种上下文：程序上下文和请求上下文
程序上下文：程序上下文中存储了程序运行所必须的信息。
请求上下文：包含了请求的各种信息，比如请求的URL，请求的HTTP方法等。


1，每一个视图函数都需要上下文信息，Flask将请求报文封装在request对象中，在Flask中，直接导入一个全局的request对象，然后再视图函数里直接调用request的属性获取
数据，PS：在全局导入时 request只是一个普通的Python对象，但在处理请求时，视图函数里的request就会自动包含对应请求的数据，因为Flask会在每个请求产生后自动激活
当前请求的上下文，激活请求上下文后，request被临时设为全局可访问。而当每个请求结束后，Flask就销毁对应的请求上下文。所以说，这里的request是全局对象，但这里的
“全局”并不是实际意义上的全局，我们可以把这些变量理解为动态的全局变量。

为了方便获取这两种上下文环境中存储的信息，Flask提供了四个上下文全局变量，如下：
变量名             上下文类别               说明
current_app     程序上下文              指向处理请求的当前程序实例
g                     程序上下文              替代Python的全局变量用法，确保仅在当前请求中可用。用于存储全局数据，每次请求都会重设
request           请求上下文               封装客户端发出的请求报文数据
session            请求上下文              用于记住请求之间的数据，，通过前面的Cookie实现

关于g这个程序上下文： 因为g存储在程序上下文中，而程序上下文会随着每一个请求的进入而激活，随着每一个请求的处理完毕而销毁，所以每次请求都会重设这个值。
通常，我们会使用g结合请求钩子来保存每个请求处理前所需要的全局变量，比如当前登录的用户对象，数据库连接等。如下：
@app.route('/hello')
def hello():
       name = request.args.get('name')
       .......
如果每个视图函数都需要这个值，那么就要在每个视图函数中重复这行代码。不过，借助g我们可以将这个操作移动到before_request处理函数中执行，然后保存到g的任意属性:
from flask import g
@app.before_request
def get_name():
      g.name = request.args.get('name')
设置这个函数后，在其他视图函数中可以直接使用g.name获取对应的值，另外，g也支持使用类似字典的get()，pop()以及setdefault()方法进行操作。

下面这些情况下，Flask会自动帮我们激活程序上下文：
a,当我们使用flask run命令启动程序时。
b,使用旧的app.run()方法启动程序时。
c,执行使用@app.cli.command()装饰器注册的flask命令时。
d,使用flask shell命令启动Python Shell时。

当请求上下文被激活时，程序上下文也被自动激活。当请求处理完毕后，请求上下文和程序上下文也会自动销毁，也就是说，在请求处理时这两者拥有相同的生命周期。

2，上下文钩子：Flask为上下文提供了一个teardown_appcontext钩子，使用它注册的回调函数会在程序上下文被销毁时调用，而且通常也会在请求上下文被销毁时调用。
@app.teardown_appcontext
def teardown_db(exception):
     ...
     db.close()
使用app.teardow_appcontext装饰器注册的回调函数需要接受异常对象作为参数，当请求被正常处理时这个参数值僵尸None，这个函数的返回值将被忽略。








